<html>
    <head>
      <title>Local Portal</title>
    </head>
    <body style="overflow: hidden;">

        <div id="offlineDiv" style="display: none;right:20px;top:10px;color:#ffaaaa;position:fixed;">No internet connection</div>
        <div id="timerDisplay" style="position:fixed; font-size:small;color:green;top: 20px; right: 20px;display:none"></div>
        
        
        <div style="padding-right:10px;display: flex; flex-direction: row; align-items: center; height: 50px; top: 0px; left: 0px; width: 100%; position: absolute; background: rgb(59, 129, 246); color: white;"><div style="flex: 1 1 0%;"><div class="chat-title" id="chat-title"></div></div><button type="button" class="py-2 px-4 justify-center font-semibold text-white focus:outline-none flex items-center disabled:opacity-50 disabled:cursor-not-allowed disabled:brightness-100 transition-all filter hover:brightness-90 active:brightness-75 chatbot-button my-2 ml-2" title="New Chat" sendbuttoncolor="white" isdisabled="false" style="background: transparent; border: none;" onclick="cleareChatHistory();"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-refresh" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="white"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4"></path><path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path></svg></button></div>
        <div style="margin-top:30px">&nbsp;</div>
        <div class="chat-actions" id="chat-actions"></div>
        <div class="chat-container"></div>
        
        
        <!-- Typing container -->
        <div class="typing-container">
            <div class="typing-content">
                <div class="typing-textarea">
                    <textarea id="chat-input" spellcheck="false" required style="background-color:white;" placeholder="Chat"></textarea>
                    <span id="send-btn" style="color:blue;">&#10147;</span>
                </div>
            </div>
        </div>
        <div id="progressBarContainer" style="display:none; position:fixed; bottom: 2px; left: 0; right: 0; width: 200px; height:2px; background-color: #ddd; margin: auto;">
          <div id="progressBar" style="height: 100%; width: 0%; background-color: green;"></div>
        </div>
<script language="javascript">
    const queryParams = new URLSearchParams(window.location.search);
    const chatContainer = document.querySelector(".chat-container");
    const chatInput = document.querySelector("#chat-input");
    const chatTitle = document.querySelector(".chat-title");
    const sendButton = document.querySelector("#send-btn");
    const configfile = queryParams.get('configfile');
    loadAndStoreConfig(configfile);

    var initialInputHeight =60;
    let userText = null;
    let welcomeText = null;
   

    function checkInternet() {
        if (!navigator.onLine) {
            // If offline, show the div
            document.getElementById('offlineDiv').style.display = 'block';
        } else {
            // If online, hide the div
            document.getElementById('offlineDiv').style.display = 'none';
        }
    }

    // Check for Internet connection on page load
    checkInternet();
    // Add event listeners for the browser going online or offline
    window.addEventListener('online', checkInternet);
    window.addEventListener('offline', checkInternet);


    async function loadAndStoreConfig(configfile) {
          const response = await fetch(configfile);
          const data = await response.text();
          let datamodified = data.replace(/(--header [^\n]+)/g, (match) => match.replace(/'/g, '"'));
          localStorage.setItem("configParameters", datamodified);
          let defaultactions = null;
          let backgroundImage = null;

          const designfile = configfile + ".json";
          const designresponse = await fetch(designfile);
          const designdata = await designresponse.json();
          var actionButtons = '';

          for (const url in designdata) {
            const config = designdata[url];
       
            if (config.outputpath) {
              localStorage.setItem('outputpath', config.outputpath);
            }
            if (config.welcome) {
              welcomeText = config.welcome;
            }
            
            if (config.backgroundImage) {
              backgroundImage = config.backgroundImage;
          
              // Create a new div element
              var backgroundDiv = document.createElement('div');
          
              // Apply styles to the div
              backgroundDiv.style.position = 'fixed';
              backgroundDiv.style.top = '0';
              backgroundDiv.style.left = '0';
              backgroundDiv.style.width = '100%';
              backgroundDiv.style.height = '100%';
              backgroundDiv.style.backgroundImage = "url('" + backgroundImage + "')";
              backgroundDiv.style.backgroundSize = 'cover';
              backgroundDiv.style.backgroundRepeat = 'no-repeat';
              backgroundDiv.style.backgroundPosition = 'center center';
              backgroundDiv.style.opacity = '0.1'; // 50% transparency
              backgroundDiv.style.zIndex = '-1'; // Ensures the div is behind other content
          
              // Append the div to the body
              document.body.appendChild(backgroundDiv);
          }
            console.log("background image"+backgroundImage)

            if(config.defaultactions)
            {
              defaultactions = config.defaultactions;

              // Extracting the labels and creating buttons
              var matches = defaultactions.match(/\[button (.*?)\]/g);
              if (matches) {
                  matches.forEach(function(match) {
                      var label = match.replace('[button ', '').replace(']', ''); // Extract the label
                      actionButtons = actionButtons + createButton(label); // Create a button with this label
                  });
              }


              //welcomeText = welcomeText + "<p>" + actionButtons+"</p>";

            
            if(config.title)
            {
              chatTitle.innerHTML = config.title;
            }
              
              const incomingChatDiv = createChatElement(welcomeText, "incoming");
              chatContainer.appendChild(incomingChatDiv);
              chatContainer.scrollTo(0, chatContainer.scrollHeight);
            }
          }
    }

    function setInputAndSubmit(label) {
      // Set the value of chat-input to the label
      document.getElementById('chat-input').value = label;
  
      // Call the function that handles submission (similar to clicking the send button)
      handleOutgoingChat();
  }

    // Function to create a button and assign an alert to it
    function createButton(label) {
      // Create the button HTML as a string with an onclick event that sets chat-input value and calls handleOutgoingChat
      var buttonHtml = '<input type="button" onclick="setInputAndSubmit(\'' + label + '\')" value="' + label + '" style="padding-left:5px">';

  
      return buttonHtml; // Return the button HTML string
  }

    // Initialize a chat history array
    let chatHistory = [];
      // Function to update the chat history array and save it to storage
      const cleareChatHistory = () => {
        const queryParams = new URLSearchParams(window.location.search);
        const title = queryParams.get('title'); // Get title from URL query parameters

        // Push the latest message to the chat history
        chatHistory = [];
        chatContainer.innerHTML = "";
        // Save the updated chat history to local storage using the title as the key
        localStorage.setItem(title + "History", "");
        localStorage.setItem("seed", "");
      
        if (welcomeText !== null ) {
          const incomingChatDiv = createChatElement(welcomeText, "incoming");
          chatContainer.appendChild(incomingChatDiv);
          chatContainer.scrollTo(0, chatContainer.scrollHeight);
        }
    };


    let requestQueue = [];

    let totalRequestTime = 0;
let requestCount = 0;

function extractValuesByKey(obj, key) {
  let values = [];
 
  function extract(obj, key) {
      // Check if obj is an object or array, and iterate over it
      if (typeof obj === 'object' && obj !== null) {
          for (const k in obj) {
              if (k === key) {
        
                  // If the key matches, add the value to the array
                  values.push(obj[k]);
              } else if (typeof obj[k] === 'object') {
                  // If the value is an object or array, recursively search inside it
                  extract(obj[k], key);
              }
          }
      }
  }
  extract(obj, key);
  return values;
}

const updateTimerDisplay = (timeLeft, totalTime) => {

  let progressBarContainer = document.getElementById('progressBarContainer');
  let progressBar = document.getElementById('progressBar');

  if (timeLeft > 0) {
      let progressPercent = ((totalTime - timeLeft) / totalTime) * 100;
      progressBar.style.width = progressPercent.toFixed(0) + '%';
      progressBarContainer.style.display = 'block'; // Show the progress bar container
  } else {
      progressBarContainer.style.display = 'none'; // Hide the progress bar container when timeLeft is 0 or less
  }
};


const startTimer = () => {
  let averageTime = requestCount > 0 ? Math.floor(totalRequestTime / requestCount) : 5000; // average time in milliseconds
  let totalTime = averageTime;
  let timeLeft = totalTime;

  updateTimerDisplay(timeLeft, totalTime);

  const timer = setInterval(() => {
    timeLeft -= 100; // Decrement time left by 100 milliseconds
    updateTimerDisplay(timeLeft, totalTime);

    if (timeLeft <= 0) {
      clearInterval(timer);
      updateTimerDisplay(0, totalTime); // Ensure it displays 100% at the end
    }
  }, 100); // Update every 100 milliseconds

  return timer;
};


let isProcessingQueue = false;

const processQueue = async () => {
    if (isProcessingQueue) {
        return;
    }

    isProcessingQueue = true;

    while (requestQueue.length > 0) {

        const nextRequest = requestQueue.shift(); // Take the first request from the queue
        const startTime = Date.now();
        let timer = startTimer(Math.floor(totalRequestTime / requestCount));
  

        try {

            const data = await syncfetch(nextRequest.prompt);
            clearInterval(timer);
            const requestTime = Date.now() - startTime;
            updateTimerDisplay(0, 1);
      
            totalRequestTime += requestTime;
            requestCount++;
            
        } catch (error) {
            clearInterval(timer);
            console.error("Error in request:", error);
        }
    }

    isProcessingQueue = false;
};

const enqueueRequest = (prompt) => {
    requestQueue.push({ prompt });
    processQueue();
};
    
const syncfetch = (prompt) => {
  const configParameters = localStorage.getItem("configParameters");
  let seed = localStorage.getItem('seed'); 
  let curlCommandFinal = configParameters.replace(/\[prompt\]/g, prompt);
  curlCommandFinal = curlCommandFinal.replace(/\[seed\]/g, seed);
  const fetchOptions = curlToFetch(curlCommandFinal);
  let apiResponse = '';
  var contents;
  console.log(fetchOptions);

  const itemProperty = fetchOptions.outputpath; // Specify the property name you want to access

  if (fetchOptions.outputpath) {
    localStorage.setItem('outputpath', fetchOptions.outputpath);
  }
  
    // Now you can use fetch with the fetchOptions to make the request
    fetch(fetchOptions.url, {
      method: fetchOptions.method,
      headers: fetchOptions.headers,
      body: fetchOptions.body
    })
    .then(response => response.json())
    .then(data => {
        console.log(data);

        // Retrieve the outputpath from localStorage
        const outputpath = localStorage.getItem('outputpath');

        // Ensure that outputpath is available and valid


     

        // Retrieve all values matching the key 'content'
      // Extract contents using the specified key
        contents = extractValuesByKey(data, outputpath);

        // Iterate through each content
        contents.forEach(content => {
            if (Array.isArray(content)) {
                // If content is an array, append each item
                content.forEach(item => {
                    apiResponse += item + '\n';
                });
            } else {
                // If content is not an array, append it directly
                apiResponse += content + '\n';
            }
            console.log(content);
        });

        const queryParams = new URLSearchParams(window.location.search);
        const title = queryParams.get('title'); // Get title from URL query parameters
        var apiLink = '';
    
        apiLink = replaceImageLinks(apiResponse);
        updateChatHistory(apiLink, 'assistant', title);
        
      

        const incomingChatDiv = createChatElement(apiLink, "incoming");
        chatContainer.appendChild(incomingChatDiv);
        chatContainer.scrollTo(0, chatContainer.scrollHeight);
    });

   

    return contents;
}


function replaceImageLinks(responseText) {
  // Regular expression to match URLs in the text
  const urlRegex = /(https?:\/\/[^\s]+)/g;

  // Replace URLs with HTML links and images in the entire responseText
  responseText = responseText.replace(urlRegex, (url) => {
      // Extract and save any trailing punctuation
      let trailingPunctuation = url.match(/[,.]$/) ? url.slice(-1) : '';
      let cleanUrl = url.replace(/[,.]$/, ''); // Remove trailing punctuation from the URL

      if (cleanUrl.toLowerCase().includes('.png') || cleanUrl.toLowerCase().includes('.jpg')) {
          return `<a href="${cleanUrl}" target="_blank"><img src="${cleanUrl}" alt="Image" style="min-width:300px;height:auto;padding:5px;" /></a>${trailingPunctuation}`;
      } else {
          return `<a href="${cleanUrl}" target="_blank">${cleanUrl}</a>${trailingPunctuation}`;
      }
  });

  // Find the index of the "More:" title
  const moreIndex = responseText.indexOf("More:");
  if (moreIndex === -1) return responseText; // If "More:" is not found, return the modified text

  // Split the responseText into two parts: before and after "More:"
  const beforeMore = responseText.substring(0, moreIndex);
  let afterMore = responseText.substring(moreIndex);

  // Regular expression to match suggestions (assuming they start with '- ' followed by text)
  const suggestionRegex = /-\s([^\n]+)/g;

  // Replace suggestions with clickable links in the 'afterMore' part
  afterMore = afterMore.replace(suggestionRegex, (match, suggestion) => {
      // Check if the last character of the suggestion is a comma or period
      let lastChar = suggestion.slice(-1);
      let displaySuggestion = suggestion;
      let actionSuggestion = suggestion;

      if (lastChar === ',' || lastChar === '.') {
          // Remove the last character from the action part of the suggestion
          actionSuggestion = suggestion.slice(0, -1);
      }

      return `<a href="javascript:void(0);" onclick="setInputAndSubmit('${actionSuggestion}')" style="color:blue;text-decoration:underline;">${displaySuggestion}</a>`;
  });

  // Combine the 'beforeMore' and 'afterMore' parts
  return beforeMore + afterMore;
}



    // Function to update the chat history array and save it to storage
    const updateChatHistory = (message, role, title) => {
        // Push the latest message to the chat history
        chatHistory.push({
            role: role,
            content: message,
         });

        // Save the updated chat history to local storage using the title as the key
        localStorage.setItem(title + "History", JSON.stringify(chatHistory));
    };

    const createChatElement = (content, className) => {
        // Create new div and apply chat, specified class and set html content of div
        var formattedResponse = content.replace(/\n/g, "<br>");
         // Replace URLs with anchor tags
      
        const chatDiv = document.createElement("div");
        chatDiv.classList.add("chat", className);
        chatDiv.innerHTML = formattedResponse;
        return chatDiv; // Return the created chat div
    }

    // Function to load chat history from storage based on title in URL on page load
    const loadChatHistory = () => {
        // Retrieve the title from URL query parameters
        const queryParams = new URLSearchParams(window.location.search);
        const title = queryParams.get('title'); 
        var className;

 

        // Use the title to construct the key for local storage
        const chatHistoryKey = title + "History";

        // Fetch and parse the chat history using the constructed key
        const storedChatHistory = localStorage.getItem(chatHistoryKey);

        if (storedChatHistory) {
            chatHistory = JSON.parse(storedChatHistory);
            
            
            chatHistory.forEach(chat => {
                // Determine the class name based on the role
                if (chat.role != 'assistant')
                  className = "incoming";
                else
                  className = "outgoing";

                console.log("role"+chat.role);
                // Create the chat element
            
                const chatElement = createChatElement(chat.content, className);
       
                chatContainer.appendChild(chatElement);
                chatContainer.scrollTo(0, chatContainer.scrollHeight);
            });
        }
        //
    };
    loadChatHistory();

    
   

    const getChatResponse = async (incomingChatDiv) => {
        const pElement = document.createElement("div");
        const queryParams = new URLSearchParams(window.location.search);
        const title = queryParams.get('title'); // Get title from URL query parameters
        const configParameters = localStorage.getItem("configParameters");

        updateChatHistory(userText, 'user', title);
        localStorage.setItem("all-chats", chatContainer.innerHTML);
        chatContainer.scrollTo(0, chatContainer.scrollHeight);
    }
    
    const copyResponse = (copyBtn) => {
        // Copy the text content of the response to the clipboard
        const reponseTextElement = copyBtn.parentElement.querySelector("div");
        navigator.clipboard.writeText(reponseTextElement.textContent);
        copyBtn.textContent = " ";
        setTimeout(() => copyBtn.textContent = "c", 1000);
    }

    
    const handleOutgoingChat = () => {
        const queryParams = new URLSearchParams(window.location.search);
        const title = queryParams.get('title'); // Get title from URL query parameters
        let seed = localStorage.getItem('seed'); // Try to get seed from localStorage

        if (!seed) {
            // Combine Date.now() with a random number to create a more unique seed
            const randomNum = Math.floor(Math.random() * 1000000); // Generate a random number
            seed = 'seed_' + Date.now() + '_' + randomNum;
            localStorage.setItem('seed', seed); // Store the new seed in localStorage
        }

        userText = chatInput.value.trim(); // Get chatInput value and remove extra spaces
        userText = userText.charAt(0).toUpperCase() + userText.slice(1);
        if(!userText) return; // If chatInput is empty return from here
    
       

        // Clear the input field and reset its height
        chatInput.value = "";
        chatInput.style.height = `${initialInputHeight}px`;
    
        if(userText=="/clear")
        {
          cleareChatHistory();
          return;
        }

        const html = `${userText}`;
        updateChatHistory(userText,seed,title);

        // Create an outgoing chat div with user's message and append it to chat container
        const outgoingChatDiv = createChatElement(html, "user");
        chatContainer.appendChild(outgoingChatDiv);
        chatContainer.scrollTo(0, chatContainer.scrollHeight);
        enqueueRequest(userText);
        //syncfetch(userText);
    }
    
    
    chatInput.addEventListener("input", () => {   
        // Adjust the height of the input field dynamically based on its content
       // chatInput.style.height =  `${initialInputHeight}px`;
       if(chatInput.scrollHeight>initialInputHeight)
        chatInput.style.height = `${chatInput.scrollHeight}px`;
    });
    
    chatInput.addEventListener("keydown", (e) => {
        // If the Enter key is pressed without Shift and the window width is larger 
        // than 800 pixels, handle the outgoing chat
        if (e.key === "Enter" && !e.shiftKey && window.innerWidth > 800) {
            e.preventDefault();
            handleOutgoingChat();
        }
    });

    
    sendButton.addEventListener("click", handleOutgoingChat);
            </script>


            <style>
              .chat-title{
                font-weight:bold;
                font-size:medium;
                padding:10px;
              }
              

                /* Toggle class styles */
                .menu-open .line:nth-child(1) {
                    transform: translateY(11px) rotate(45deg);
                }
                
                .menu-open .line:nth-child(2) {
                    opacity: 0;
                }
                
                .menu-open .line:nth-child(3) {
                    transform: translateY(-11px) rotate(-45deg);
                }
                
                .nav-menu {
                    display: none;
                }
                
                /* Style for when navigation is shown */
                .show-menu {
                    display: block;
                }
                
                
                .sidebar-option {
                  padding: 10px;
                  cursor: pointer;
                }
                
                .sidebar-option:hover {
                  background-color: #aaffaa;
                }
                  
                /* Active Tab Styling */
                .tab.active {
                  background-color: transparent; /* Set background to transparent */
                  border-bottom: 2px solid gray; /* Optional: add a bottom border to highlight the active tab */
                }
                
                  /* Bottom Tab Container Styling */
                .bottom-tab-container {
                  display: flex;
                  justify-content: space-around;
                  position: fixed;
                  top: 0px;
                  width: 100%;
                  height:60px;
                  background-color: white; /* or any color you prefer */
                  color: #333333;
                  z-index:10;
                }
                
                .tab {
                  padding: 10px 20px;
                  border: none;
                  background: none;
                  color: gray;
                  font-size: 16px;
                  cursor: pointer;
                }
                
                /* Additional spacing for the typing container */
                .typing-container {
                  padding-top:40px;
                  margin-bottom: 0px; /* Adjust this value based on the height of your tabs */
                }
                  
                  .container {
                    
                    height: 100%; /* Set the container's height to 100% */
                  }
                  
                  #grid-container {
                    flex: 1;
                    /* Your grid styles */
                  }
                  
                  #sidebar {
                    position:fixed;
                    top: 0; /* Position it at the top of the viewport */
                  left: 0; /* Position it at the right side of the viewport */
                  width: 200px; /* Set a fixed width */
                  height: 100vh; /* Set the height to 100% of the viewport height */
                  background-color: black;
                  color: white;
                  padding: 16px;
                  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
                  overflow-y: auto; /* Add scrollbars if content exceeds sidebar height */
                  }
                
                  #sidebar a {
                  color: white;
                  text-decoration: none; /* Remove underlines from links */
                }
                  
                  #close-sidebar-button {
                    position: absolute;
                    top: 8px;
                    right: 8px;
                  }
                    /* CSS for the fixed-bottom div */
                .fixed-bottom {
                  width: 100%;
                  background-color: black; /* Background color for the div */
                  padding: 10px; /* Adjust padding as needed */
                  border-top: 1px solid #cccccc; /* Optional: Add a border at the top */
                }
                
                   /* API Config Dialog Styles */
                .config-dialog {
                  display: none;
                  position: fixed;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%, -50%);
                  background-color: #fff;
                  padding: 20px;
                  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
                  z-index: 9999;
                }
                
                .config-dialog h2 {
                  font-size: 1.5rem;
                  margin-bottom: 10px;
                }
                
                .config-dialog label {
                  font-size: 1rem;
                  margin-bottom: 5px;
                  display: block;
                }
                
                .config-dialog input {
                  width: 100%;
                  padding: 5px;
                  margin-bottom: 10px;
                }
                
                .config-dialog button {
                  background-color: #007bff;
                  color: #fff;
                  border: none;
                  padding: 10px 20px;
                  cursor: pointer;
                  margin-right: 10px;
                }
                
                .config-dialog button:hover {
                  background-color: #0056b3;
                }
                
                * {
                  margin: 0;
                  padding: 0;
                  box-sizing: border-box;
                  font-family: "Poppins", sans-serif;
                }
                :root {
                  --text-color: #333333;
                  --icon-color: #ACACBE;
                  --icon-hover-bg: #5b5e71;
                  --placeholder-color: #dcdcdc;
                  --outgoing-chat-bg: rgba(240, 240, 255, 0.5); /* 50% transparent white */
                  --incoming-chat-bg: rgba(255, 255, 255, 0.5); /* 50% transparent white */
                  --outgoing-chat-border: white;
                  --incoming-chat-border: white;
                }
                
                .light-mode {
                  --text-color: #343541;
                  --icon-color: #a9a9bc;
                  --icon-hover-bg: #f1f1f3;
                  --placeholder-color: #6c6c6c;
                  --outgoing-chat-bg: #FFFFFF;
                  --incoming-chat-bg: #F7F7F8;
                  --outgoing-chat-border: #FFFFFF;
                  --incoming-chat-border: #D9D9E3;
                }
                body {
                  background: var(--outgoing-chat-bg);
                }
                
                /* Chats container styling */
                .chat-container {
                  overflow-y: auto;
                  max-height: 100vh;
                  padding-bottom: 150px;
                }
                :where(.chat-container, textarea)::-webkit-scrollbar {
                  width: 6px;
                }
                :where(.chat-container, textarea)::-webkit-scrollbar-track {
                  background: var(--incoming-chat-bg);
                  border-radius: 25px;
                }
                :where(.chat-container, textarea)::-webkit-scrollbar-thumb {
                  background: var(--icon-color);
                  border-radius: 25px;
                }
                .default-text {
                  padding: 0 10px;
                  text-align: center;
                  top:0px;
                  position:fixed;
                  background-color:white;
                  width:100%;
                }
                .chat-container .chat {
                  padding: 15px 10px;
                  display: block;
                  justify-content: left;
                  color: var(--text-color);
                }
                .chat-container .chat.outgoing {
                  background: var(--outgoing-chat-bg);
                  border: 1px solid var(--outgoing-chat-border);
                }
                .chat-container .chat.incoming {
                  background: var(--incoming-chat-bg);
                  border: 1px solid var(--incoming-chat-border);
                }
                .chat .chat-content {
                  display: flex;
                  max-width: 1200px;
                  width: 100%;
                  align-items: flex-start;
                  justify-content: space-between;
                }
                span.material-symbols-rounded {
                  user-select: none;
                  cursor: pointer;
                }
                .chat
                {
                  padding-top:5px;
                  padding-bottom:5px;
                }
                .chat .chat-content span {
                  cursor: pointer;
                  font-size: 1.3rem;
                  color: var(--icon-color);
                  visibility: hidden;
                }
                .chat:hover .chat-content:not(:has(.typing-animation), :has(.error)) span {
                  visibility: visible;
                }
                .chat .chat-details {
                  display: flex;
                  align-items: center;
                }
                .chat .chat-details img {
                  width: 35px;
                  height: 35px;
                  align-self: flex-start;
                  object-fit: cover;
                  border-radius: 2px;
                }
                .chat .chat-details p {
                  white-space: pre-wrap;
                  font-size: 1.05rem;
                  padding: 0 50px 0 25px;
                  color: var(--text-color);
                  word-break: break-word;
                }
                .chat .chat-details p.error {
                  color: #e55865;
                }
                .chat .typing-animation {
                  padding-left: 25px;
                  display: inline-flex;
                }
                .typing-animation .typing-dot {
                  height: 7px;
                  width: 7px;
                  border-radius: 50%;
                  margin: 0 3px;
                  opacity: 0.7;
                  background: var(--text-color);
                  animation: animateDots 1.5s var(--delay) ease-in-out infinite;
                }
                .typing-animation .typing-dot:first-child {
                  margin-left: 0;
                }
                @keyframes animateDots {
                  0%,44% {
                    transform: translateY(0px);
                  }
                  28% {
                    opacity: 0.4;
                    transform: translateY(-6px);
                  }
                  44% {
                    opacity: 0.2;
                  }
                }
                
                /* Typing container styling */
                .typing-container {
                  position: fixed;
                  bottom: 0%;
                  width: 100%;
                  display: flex;
                  padding: 20px 10px;
                  justify-content: center;
                  background: rgba(255, 255, 255, 0.1);
                
                }
                .typing-container .typing-content {
                  display: flex;
                  max-width: 950px;
                  width: 100%;
                  align-items: flex-end;
                }
                .typing-container .typing-textarea {
                  width: 100%;
                  display: flex;
                  position: relative;
                }
                
                
                @keyframes rainbow {
                  0% { border-color: red; }
                  14% { border-color: orange; }
                  28% { border-color: rgb(255, 208, 0); }
                  42% { border-color: green; }
                  57% { border-color: blue; }
                  71% { border-color: indigo; }
                  85% { border-color: violet; }
                  100% { border-color: red; }
                }
                
                .typing-textarea textarea {
                  resize: none;
                  height: 60px;
                  width: 100%;
                  padding: 15px 45px 15px 20px;
                  border: 1px solid #aabbff; /* Adjusted for visibility of the animation */
                  color: var(--text-color);
                  font-size: 1rem;
                  border-radius: 4px;
                  max-height: 250px;
                  overflow-y: auto;
                  background: var(--incoming-chat-bg);
                  outline: 1px solid var(--incoming-chat-border);
                  animation: rainbow 10s infinite; /* Apply the animation here */
                }
                
                .typing-textarea textarea::placeholder {
                  color: var(--placeholder-color);
                }
                .typing-content span {
                  width: 55px;
                  height: 55px;
                  display: flex;
                  border-radius: 4px;
                  font-size: 1.35rem;
                  align-items: center;
                  justify-content: center;
                  color: var(--icon-color);
                }
                .typing-textarea span {
                  position: absolute;
                  right: 0;
                  bottom: 0;
                  visibility: hidden;
                }
                .typing-textarea textarea:valid ~ span {
                  visibility: visible;
                }
                .chat.user {
                  font-weight: bold;
                  justify-content: right;
                  text-align:right;
               }
                .typing-controls {
                  display: flex;
                }
                .typing-controls span {
                  margin-left: 7px;
                  font-size: 1.4rem;
                  background: var(--incoming-chat-bg);
                  outline: 1px solid var(--incoming-chat-border);
                }
                .typing-controls span:hover {
                  background: var(--icon-hover-bg);
                }
                
                /* Reponsive Media Query */
                @media screen and (max-width: 600px) {
                  .chat-container .chat {
                    padding: 20px 10px;
                  }
                  .chat-container .chat img {
                    height: 32px;
                    width: 32px;
                  }
                  .chat-container .chat p {
                    padding: 0 20px;
                  }
                  .chat .chat-content:not(:has(.typing-animation), :has(.error)) span {
                    visibility: visible;
                  }
                  .typing-container {
                    padding: 15px 10px;
                  }
                  .typing-textarea textarea {
                    height: 50px;
                    padding: 10px 40px 10px 10px;
                  }
                  .typing-content span {
                    height: 45px;
                    width: 45px;
                    margin-left: 5px;
                  }
                  span.material-symbols-rounded {
                    font-size: 1.25rem!important;
                  }
                }
                  </style>
<script language="javascript">

  document.addEventListener('DOMContentLoaded', function() {
    // Assuming xinput is the div with class 'chat incoming'
    var chatIncoming = document.querySelector('.chat.incoming')
    if(chatIncoming) {
        // Extract the 'More' section
        var moreSection = chatIncoming.innerHTML.split('More:<br>')[1];
        if(moreSection) {
            // Split the section into individual suggestions
            var suggestions = moreSection.split('<br>');
            suggestions.forEach(function(suggestion, index) {
                // Create a span element for each suggestion
                var suggestionSpan = document.createElement('span');
                suggestionSpan.innerHTML = suggestion;
                suggestionSpan.style.cursor = 'pointer'; // Optional: for better UX
                suggestionSpan.addEventListener('click', function() {
                    setInputAndSubmit(this.textContent);
                });

                // Replace the original text with the clickable span
                chatIncoming.innerHTML = chatIncoming.innerHTML.replace(suggestion, suggestionSpan.outerHTML);
            });
        }
    }
});




  function curlToFetch(curlCommand) {
    const fetchOptions = {};
  
    // Extract the URL
    const urlMatches = curlCommand.match(/(https?:\/\/[^\s]+)/);
    if (urlMatches && urlMatches.length >= 1) {
      fetchOptions.url = urlMatches[0];
    } else {
      throw new Error('Invalid curl command: URL not found.');
    }
  
   // Extract headers using both --header and -H
    const headerMatches = curlCommand.match(/(--header|-H) "([^"]+): ([^"]+)"/g);
    if (headerMatches) {
      fetchOptions.headers = {};
      headerMatches.forEach(headerMatch => {
        const headerParts = headerMatch.match(/(--header|-H) "([^"]+): ([^"]+)"/);
        if (headerParts && headerParts.length >= 4) {
          fetchOptions.headers[headerParts[2]] = headerParts[3];
        }
      });
    }
    
    // Extract method
    const methodMatches = curlCommand.match(/--request ([A-Z]+)/);
    if (methodMatches && methodMatches.length >= 2) {
      fetchOptions.method = methodMatches[1];
    } else {
      fetchOptions.method = 'POST'; // Default to POST if method is not specified
    }
  
    // Extract data using both --data and -d
    const dataMatches = curlCommand.match(/(--data|-d) '([^']+)'/);
    if (dataMatches && dataMatches.length >= 3) {
      const dataString = dataMatches[2];
      //try {
        const jsonData = JSON.parse(dataString);
        if (jsonData.outputpath) {
          fetchOptions.outputpath = jsonData.outputpath; // Update to match the new field name
        }
        if (jsonData.welcome) {
          fetchOptions.welcome = jsonData.welcome; // Update to match the new field name
        }
        if (jsonData.title) {
          fetchOptions.title = jsonData.title; // Update to match the new field name
        }
        if (jsonData.description) {
          fetchOptions.description = jsonData.description; // Update to match the new field name
        }
        if (jsonData.placeholder) {
          fetchOptions.placeholder = jsonData.placeholder; // Update to match the new field name
        }
        // Keep fetchOptions.body as it is
        fetchOptions.body = dataString;
    //  } catch (error) {
    //    throw new Error('Invalid curl command: Error parsing JSON data.');
   //   }
    }
  
    return fetchOptions;
  }

</script>
</body>
</html>
